Deconstructing 'nukoneZ's Ransomware': A CTF Case StudyAuthor: carbonatorDate: October 16, 2025Source: crackmes.one1. IntroductionThis report details the reverse engineering process of a Capture The Flag (CTF) challenge titled "nukoneZ's Ransomware." The objective was to analyze a simulated ransomware attack, understand its mechanics, and ultimately recover a hidden flag. The provided artifacts were a malicious executable (Click_Me.exe) and a network capture file (RecordUser.pcapng).The investigation revealed a sophisticated, multi-stage operation that went far beyond simple file encryption. The solution required a combination of network forensics, static code analysis, cryptography, and the emulation of a custom virtual machine to finally uncover the flag.2. Stage 1: Initial Triage & ReconnaissanceThe investigation began by analyzing the low-hanging fruit: the network traffic and the static strings embedded within the executable.Network AnalysisAnalysis of the RecordUser.pcapng file in Wireshark immediately revealed two critical network events:An HTTP GET request to 192.168.56.1:8000 to download a file named anonymous. This was the first indication of a multi-stage payload.A TCP connection to a hardcoded C2 server at 192.168.134.132 on port 8888, during which data was exfiltrated.Figure 1: Wireshark's HTTP object export confirms the download of the anonymous file, a key component for the final stage.Static AnalysisLoading Click_Me.exe into Ghidra and examining its string table provided a clear roadmap for the investigation. Several key pieces of intelligence were discovered:Key Material: The hardcoded string hackingisnotacrime.C2 Server: The IP address 192.168.134.132.Target Files: The paths C:\ProgramData\Important\user.html and user.html.enc.Cryptography: Imported functions like EVP_aes_256_ecb and SHA256 confirmed the use of AES encryption.Figure 2: Key strings found in Click_Me.exe, including the password, C2 server, and target file.3. Stage 2: Deconstructing the Ransomware LogicWith the initial clues gathered, the next step was to trace the execution flow of Click_Me.exe in Ghidra to understand how these pieces fit together.The core logic was centered around a main orchestrator function, sub_001FB3, which coordinated the entire attack:Key Generation (sub_0016E4): The program calls a function that takes the hardcoded string hackingisnotacrime and computes its SHA256 hash. This 32-byte hash serves as the actual encryption key.Figure 3: The decompiled code shows the hackingisnotacrime string being loaded and passed to the SHA256 hashing routine sub_0016E4.Encryption (sub_00171D): The resulting hash is passed to this function, which uses the OpenSSL library to perform an AES-256-ECB encryption on the target file (user.html).C2 Communication (sub_001AEB): After encryption, this function is called. It reads the newly encrypted file from disk, connects to the C2 server at 192.168.134.132, and sends the entire encrypted file over the network. This network traffic is what was captured in the pcap file.4. Stage 3: The Twist - A Multi-Stage PayloadThe analysis showed that the program sends the encrypted file to the C2. The next logical step was to decrypt this data to find the flag. Using a Python script, we took the ciphertext from the pcap, generated the SHA256 key, and ran the AES decryption.The result was not a flag. The decrypted data began with the bytes 4D 5A (or MZ in ASCII), the magic number for a Windows executable.Figure 4: The decryption script reveals the payload is not a flag, but another executable file (a DLL).This was the major turning point. The ransomware's primary goal was not to destroy a file, but to encrypt and exfiltrate a hidden, second-stage DLL. The original user.html was a decoy filename for this library.5. Stage 4: The Final Secret - A Custom Virtual MachineThe decrypted payload was saved as decrypted_library.dll and loaded back into Ghidra for a final round of analysis. The DLL exported three functions: gen_from_file, get_result_bytes, and reset_vm_state.The core logic was found within an internal function named gen. This function was a custom-built virtual machine (VM). It reads bytecode from an input file and executes a series of simple instructions (store, add, subtract, and XOR) to manipulate data in memory.Figure 5: The core of the custom VM inside the decrypted DLL, which processes bytecode instructions.The input for this VM—the bytecode—was the anonymous file that the ransomware downloaded in the very first step of its execution.Figure 6: The bytecode instructions for the VM, as contained in the anonymous file.6. Stage 5: Flag RecoveryThe final step was to emulate the VM's logic. A Python script was written to parse the anonymous bytecode and execute the VM's instruction set, simulating its memory buffers and operations. The final XOR instruction (opcode 4) was responsible for building the flag, character by character.Running the emulator script with the correct bytecode produced the final, decoded flag.Figure 7: The successful execution of the VM emulator script, revealing the final flag.The Flagr4ns0mw@rE_c4n_d357r0y_f1l3s_n0w
7. ConclusionThis challenge was a masterful example of layered complexity. What began as a straightforward ransomware analysis evolved into a multi-stage investigation involving network forensics, cryptography, and ultimately, the reverse engineering of a custom virtual machine. The key takeaway is the importance of correlating different sources of evidence—the network traffic provided the bytecode, and the executable provided the key and the VM to run it. By carefully deconstructing each layer, we were able to recover the final flag.
